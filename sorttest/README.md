# Extra-credit Assignment: Timing Different Versions of BubbleSort

This program implements the bubble sort algorithm using several different ways of accessing array elements in C, and compares the amount of time the various versions take.

## Three versions of bubble sort
1. sortDescending: Use the original way to traverse through array: index-based notion. Ex: a[i].
2. mySort1: Use a similar way to traverse through array by pointer. Ex: *(a + i).
3. mySort2: Use incrementing pointer to traverse through array. Ex: *(a++).

## Essential Files to Compile to Program
1. sort.h: header file for sort, containing all function prototypes regarding sorting.
2. sort.c: source code file, implementing three different versions of bubble sort.
3. timesort.c: source code file that executes and retrieves the running time of the specified version of bubble sort.
4. sorttest.c: source code file whose main function will test and demonstrate the default bubble sort (sortDescending function).
5. sorttest2.c: source code file whose main function will test and demonstrate the chosen version of bubble sort. 
6. Makefile: to generate two executable file (sorttest and sorttest2), whose function is to test the demonstrate the running time of bubble sort.

## Command-line arguments
1. For sorttest:

    `./sorttest num1 num2 [num3] [...]`

    where:
  
    - num1, num2, num3, ... are integers to be sorted. 
    - At least num1 and num2 must be given.
2. For sorttest2: 

    `./sorttest2 size [option]`

    where:
    - Size is the size of a randomized array to be generated by the program.
    - Option is specified to choose which version of bubble sort to test running time. 0 is default value for testing sortDescending, 1 is to test mySort1, 2 is to test mySort2.
   
## How to compile and run the program
1. Navigate to the folder containing the source files. Check all the necessary files' existence.
2. Compile the program by running: 

    `make all`
3. Run the executable:
    `./sorttest num1 num2 [num3] [...]`

    or 

    `./sorttest2 size [option]`

4. Enjoy!

## Data Collected
| size of array | sortDescending                    | mySort1                           | mySort2                           |
| :-----------: | :-------------------------------: | :-------------------------------: | :-------------------------------: |
| 500           | Seconds, 0, Microseconds: 616     | Seconds, 0, Microseconds: 610     | Seconds, 0, Microseconds: 545     |
| 1000          | Seconds, 0, Microseconds: 2562    | Seconds, 0, Microseconds: 2579    | Seconds, 0, Microseconds: 2377    |
| 2000          | Seconds, 0, Microseconds: 10184   | Seconds, 0, Microseconds: 10803   | Seconds, 0, Microseconds: 8693    |
| 4000          | Seconds, 0, Microseconds: 48098   | Seconds, 0, Microseconds: 46969   | Seconds, 0, Microseconds: 42130   |
| 8000          | Seconds, 0, Microseconds: 172865  | Seconds, 0, Microseconds: 164691  | Seconds, 0, Microseconds: 155866  |
| 16000         | Seconds, 0, Microseconds: 715824  | Seconds, 0, Microseconds: 724641  | Seconds, 0, Microseconds: 650410  |
| 32000         | Seconds, 2, Microseconds: 980620  | Seconds, 3, Microseconds: 112556  | Seconds, 2, Microseconds: 777972  |
| 64000         | Seconds, 12, Microseconds: 231367 | Seconds, 12, Microseconds: 294144 | Seconds, 11, Microseconds: 518923 |
| 128000        | Seconds, 50, Microseconds: 965390 | Seconds, 48, Microseconds: 34826  | Seconds, 45, Microseconds: 538494 | 
## Conclusion
- Let's call the running time of bubble sort of sortDescending, mySort1, and mySort2: R<sub>0</sub>, R<sub>1</sub>,R<sub>2</sub> respectively. 
- The data provided above demonstrate that: R<sub>0</sub> ~ R<sub>1</sub> < R<sub>2</sub> 
- In other word, incrementing pointer is the most efficient way to traverse through arrays, according to the data provided above.

## Author
This program is designed and implemented by Dung (Kevin) Nguyen, the owner of this repository, with the guidance from Professor Ciaraldi at Worcester Polytechnic Institute.
